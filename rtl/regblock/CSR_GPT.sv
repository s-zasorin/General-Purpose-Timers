// Generated by PeakRDL-regblock - A free and open-source SystemVerilog generator
//  https://github.com/SystemRDL/PeakRDL-regblock

module CSR_GPT (
        input wire clk,
        input wire rst,

        axi4lite_intf.slave s_axil,

        input CSR_GPT_pkg::CSR_GPT__in_t hwif_in,
        output CSR_GPT_pkg::CSR_GPT__out_t hwif_out
    );

    //--------------------------------------------------------------------------
    // CPU Bus interface logic
    //--------------------------------------------------------------------------
    logic cpuif_req;
    logic cpuif_req_is_wr;
    logic [5:0] cpuif_addr;
    logic [31:0] cpuif_wr_data;
    logic [31:0] cpuif_wr_biten;
    logic cpuif_req_stall_wr;
    logic cpuif_req_stall_rd;

    logic cpuif_rd_ack;
    logic cpuif_rd_err;
    logic [31:0] cpuif_rd_data;

    logic cpuif_wr_ack;
    logic cpuif_wr_err;

    `ifndef SYNTHESIS
        initial begin
            assert_bad_addr_width: assert($bits(s_axil.ARADDR) >= CSR_GPT_pkg::CSR_GPT_MIN_ADDR_WIDTH)
                else $error("Interface address width of %0d is too small. Shall be at least %0d bits", $bits(s_axil.ARADDR), CSR_GPT_pkg::CSR_GPT_MIN_ADDR_WIDTH);
            assert_bad_data_width: assert($bits(s_axil.WDATA) == CSR_GPT_pkg::CSR_GPT_DATA_WIDTH)
                else $error("Interface data width of %0d is incorrect. Shall be %0d bits", $bits(s_axil.WDATA), CSR_GPT_pkg::CSR_GPT_DATA_WIDTH);
        end
    `endif

    // Max Outstanding Transactions: 2
    logic [1:0] axil_n_in_flight;
    logic axil_prev_was_rd;
    logic axil_arvalid;
    logic [5:0] axil_araddr;
    logic axil_ar_accept;
    logic axil_awvalid;
    logic [5:0] axil_awaddr;
    logic axil_wvalid;
    logic [31:0] axil_wdata;
    logic [3:0] axil_wstrb;
    logic axil_aw_accept;
    logic axil_resp_acked;

    // Transaction request acceptance
    always_ff @(posedge clk) begin
        if(rst) begin
            axil_prev_was_rd <= '0;
            axil_arvalid <= '0;
            axil_araddr <= '0;
            axil_awvalid <= '0;
            axil_awaddr <= '0;
            axil_wvalid <= '0;
            axil_wdata <= '0;
            axil_wstrb <= '0;
            axil_n_in_flight <= '0;
        end else begin
            // AR* acceptance register
            if(axil_ar_accept) begin
                axil_prev_was_rd <= '1;
                axil_arvalid <= '0;
            end
            if(s_axil.ARVALID && s_axil.ARREADY) begin
                axil_arvalid <= '1;
                axil_araddr <= s_axil.ARADDR;
            end

            // AW* & W* acceptance registers
            if(axil_aw_accept) begin
                axil_prev_was_rd <= '0;
                axil_awvalid <= '0;
                axil_wvalid <= '0;
            end
            if(s_axil.AWVALID && s_axil.AWREADY) begin
                axil_awvalid <= '1;
                axil_awaddr <= s_axil.AWADDR;
            end
            if(s_axil.WVALID && s_axil.WREADY) begin
                axil_wvalid <= '1;
                axil_wdata <= s_axil.WDATA;
                axil_wstrb <= s_axil.WSTRB;
            end

            // Keep track of in-flight transactions
            if((axil_ar_accept || axil_aw_accept) && !axil_resp_acked) begin
                axil_n_in_flight <= axil_n_in_flight + 1'b1;
            end else if(!(axil_ar_accept || axil_aw_accept) && axil_resp_acked) begin
                axil_n_in_flight <= axil_n_in_flight - 1'b1;
            end
        end
    end

    always_comb begin
        s_axil.ARREADY = (!axil_arvalid || axil_ar_accept);
        s_axil.AWREADY = (!axil_awvalid || axil_aw_accept);
        s_axil.WREADY = (!axil_wvalid || axil_aw_accept);
    end

    // Request dispatch
    always_comb begin
        cpuif_wr_data = axil_wdata;
        for(int i=0; i<4; i++) begin
            cpuif_wr_biten[i*8 +: 8] = {8{axil_wstrb[i]}};
        end
        cpuif_req = '0;
        cpuif_req_is_wr = '0;
        cpuif_addr = '0;
        axil_ar_accept = '0;
        axil_aw_accept = '0;

        if(axil_n_in_flight < 2'd2) begin
            // Can safely issue more transactions without overwhelming response buffer
            if(axil_arvalid && !axil_prev_was_rd) begin
                cpuif_req = '1;
                cpuif_req_is_wr = '0;
                cpuif_addr = {axil_araddr[5:2], 2'b0};
                if(!cpuif_req_stall_rd) axil_ar_accept = '1;
            end else if(axil_awvalid && axil_wvalid) begin
                cpuif_req = '1;
                cpuif_req_is_wr = '1;
                cpuif_addr = {axil_awaddr[5:2], 2'b0};
                if(!cpuif_req_stall_wr) axil_aw_accept = '1;
            end else if(axil_arvalid) begin
                cpuif_req = '1;
                cpuif_req_is_wr = '0;
                cpuif_addr = {axil_araddr[5:2], 2'b0};
                if(!cpuif_req_stall_rd) axil_ar_accept = '1;
            end
        end
    end


    // AXI4-Lite Response Logic
    struct {
        logic is_wr;
        logic err;
        logic [31:0] rdata;
    } axil_resp_buffer[2];

    logic [1:0] axil_resp_wptr;
    logic [1:0] axil_resp_rptr;

    always_ff @(posedge clk) begin
        if(rst) begin
            for(int i=0; i<2; i++) begin
                axil_resp_buffer[i].is_wr <= '0;
                axil_resp_buffer[i].err <= '0;
                axil_resp_buffer[i].rdata <= '0;
            end
            axil_resp_wptr <= '0;
            axil_resp_rptr <= '0;
        end else begin
            // Store responses in buffer until AXI response channel accepts them
            if(cpuif_rd_ack || cpuif_wr_ack) begin
                if(cpuif_rd_ack) begin
                    axil_resp_buffer[axil_resp_wptr[0:0]].is_wr <= '0;
                    axil_resp_buffer[axil_resp_wptr[0:0]].err <= cpuif_rd_err;
                    axil_resp_buffer[axil_resp_wptr[0:0]].rdata <= cpuif_rd_data;

                end else if(cpuif_wr_ack) begin
                    axil_resp_buffer[axil_resp_wptr[0:0]].is_wr <= '1;
                    axil_resp_buffer[axil_resp_wptr[0:0]].err <= cpuif_wr_err;
                end
                axil_resp_wptr <= axil_resp_wptr + 1'b1;
            end

            // Advance read pointer when acknowledged
            if(axil_resp_acked) begin
                axil_resp_rptr <= axil_resp_rptr + 1'b1;
            end
        end
    end

    always_comb begin
        axil_resp_acked = '0;
        s_axil.BVALID = '0;
        s_axil.RVALID = '0;
        if(axil_resp_rptr != axil_resp_wptr) begin
            if(axil_resp_buffer[axil_resp_rptr[0:0]].is_wr) begin
                s_axil.BVALID = '1;
                if(s_axil.BREADY) axil_resp_acked = '1;
            end else begin
                s_axil.RVALID = '1;
                if(s_axil.RREADY) axil_resp_acked = '1;
            end
        end

        s_axil.RDATA = axil_resp_buffer[axil_resp_rptr[0:0]].rdata;
        if(axil_resp_buffer[axil_resp_rptr[0:0]].err) begin
            s_axil.BRESP = 2'b10;
            s_axil.RRESP = 2'b10;
        end else begin
            s_axil.BRESP = 2'b00;
            s_axil.RRESP = 2'b00;
        end
    end

    logic cpuif_req_masked;

    // Read & write latencies are balanced. Stalls not required
    assign cpuif_req_stall_rd = '0;
    assign cpuif_req_stall_wr = '0;
    assign cpuif_req_masked = cpuif_req
                            & !(!cpuif_req_is_wr & cpuif_req_stall_rd)
                            & !(cpuif_req_is_wr & cpuif_req_stall_wr);

    //--------------------------------------------------------------------------
    // Address Decode
    //--------------------------------------------------------------------------
    typedef struct {
        logic TIM_CR1;
        logic TIM_CR2;
        logic TIM_SMCR;
        logic TIMx_DIER;
        logic TIMx_SR;
        logic TIMx_EGR;
        logic TIMx_CCMR1;
        logic TIMx_CCER;
        logic TIM_CNT;
        logic TIM_PSC;
        logic TIM_ARR;
        logic TIM_CCR1;
    } decoded_reg_strb_t;
    decoded_reg_strb_t decoded_reg_strb;
    logic decoded_req;
    logic decoded_req_is_wr;
    logic [31:0] decoded_wr_data;
    logic [31:0] decoded_wr_biten;

    always_comb begin
        decoded_reg_strb.TIM_CR1 = cpuif_req_masked & (cpuif_addr == 6'h0);
        decoded_reg_strb.TIM_CR2 = cpuif_req_masked & (cpuif_addr == 6'h4);
        decoded_reg_strb.TIM_SMCR = cpuif_req_masked & (cpuif_addr == 6'h8);
        decoded_reg_strb.TIMx_DIER = cpuif_req_masked & (cpuif_addr == 6'hc);
        decoded_reg_strb.TIMx_SR = cpuif_req_masked & (cpuif_addr == 6'h10);
        decoded_reg_strb.TIMx_EGR = cpuif_req_masked & (cpuif_addr == 6'h14);
        decoded_reg_strb.TIMx_CCMR1 = cpuif_req_masked & (cpuif_addr == 6'h18);
        decoded_reg_strb.TIMx_CCER = cpuif_req_masked & (cpuif_addr == 6'h20);
        decoded_reg_strb.TIM_CNT = cpuif_req_masked & (cpuif_addr == 6'h24);
        decoded_reg_strb.TIM_PSC = cpuif_req_masked & (cpuif_addr == 6'h28);
        decoded_reg_strb.TIM_ARR = cpuif_req_masked & (cpuif_addr == 6'h2c);
        decoded_reg_strb.TIM_CCR1 = cpuif_req_masked & (cpuif_addr == 6'h34);
    end

    // Pass down signals to next stage
    assign decoded_req = cpuif_req_masked;
    assign decoded_req_is_wr = cpuif_req_is_wr;
    assign decoded_wr_data = cpuif_wr_data;
    assign decoded_wr_biten = cpuif_wr_biten;

    //--------------------------------------------------------------------------
    // Field logic
    //--------------------------------------------------------------------------
    typedef struct {
        struct {
            struct {
                logic next;
                logic load_next;
            } CEN;
            struct {
                logic next;
                logic load_next;
            } URS;
            struct {
                logic next;
                logic load_next;
            } OPM;
            struct {
                logic next;
                logic load_next;
            } DIR;
            struct {
                logic [1:0] next;
                logic load_next;
            } CMS;
            struct {
                logic next;
                logic load_next;
            } APRE;
            struct {
                logic [1:0] next;
                logic load_next;
            } CKD;
        } TIM_CR1;
        struct {
            struct {
                logic next;
                logic load_next;
            } CCDS;
            struct {
                logic [2:0] next;
                logic load_next;
            } MMS;
            struct {
                logic next;
                logic load_next;
            } T11S;
        } TIM_CR2;
        struct {
            struct {
                logic [2:0] next;
                logic load_next;
            } SMS;
            struct {
                logic [2:0] next;
                logic load_next;
            } TS;
            struct {
                logic next;
                logic load_next;
            } MSM;
            struct {
                logic [3:0] next;
                logic load_next;
            } ETF;
            struct {
                logic [1:0] next;
                logic load_next;
            } ETPS;
            struct {
                logic next;
                logic load_next;
            } ECE;
            struct {
                logic next;
                logic load_next;
            } ETP;
        } TIM_SMCR;
        struct {
            struct {
                logic next;
                logic load_next;
            } UIE;
            struct {
                logic next;
                logic load_next;
            } CC1IE;
            struct {
                logic next;
                logic load_next;
            } CC2IE;
            struct {
                logic next;
                logic load_next;
            } CC3IE;
            struct {
                logic next;
                logic load_next;
            } CC4IE;
            struct {
                logic next;
                logic load_next;
            } TIE;
            struct {
                logic next;
                logic load_next;
            } UDE;
            struct {
                logic next;
                logic load_next;
            } CC1DE;
            struct {
                logic next;
                logic load_next;
            } CC2DE;
            struct {
                logic next;
                logic load_next;
            } CC3DE;
            struct {
                logic next;
                logic load_next;
            } CC4DE;
            struct {
                logic next;
                logic load_next;
            } TDE;
        } TIMx_DIER;
        struct {
            struct {
                logic next;
                logic load_next;
            } UIF;
            struct {
                logic next;
                logic load_next;
            } CC1IF;
            struct {
                logic next;
                logic load_next;
            } CC2IF;
            struct {
                logic next;
                logic load_next;
            } CC3IF;
            struct {
                logic next;
                logic load_next;
            } CC4IF;
            struct {
                logic next;
                logic load_next;
            } TIF;
            struct {
                logic next;
                logic load_next;
            } CC1OF;
            struct {
                logic next;
                logic load_next;
            } CC2OF;
            struct {
                logic next;
                logic load_next;
            } CC3OF;
            struct {
                logic next;
                logic load_next;
            } CC4OF;
        } TIMx_SR;
        struct {
            struct {
                logic next;
                logic load_next;
            } UG;
            struct {
                logic next;
                logic load_next;
            } CC1G;
            struct {
                logic next;
                logic load_next;
            } CC2G;
            struct {
                logic next;
                logic load_next;
            } CC3G;
            struct {
                logic next;
                logic load_next;
            } CC4G;
            struct {
                logic next;
                logic load_next;
            } TG;
        } TIMx_EGR;
        struct {
            struct {
                logic [1:0] next;
                logic load_next;
            } CC1S;
            struct {
                logic next;
                logic load_next;
            } OC1FE_IC1PSC0;
            struct {
                logic next;
                logic load_next;
            } OC1PE_IC1PSC1;
            struct {
                logic [2:0] next;
                logic load_next;
            } OC1M_IC1F;
            struct {
                logic next;
                logic load_next;
            } OC1CE_IC1F3;
            struct {
                logic [1:0] next;
                logic load_next;
            } CC2S;
            struct {
                logic next;
                logic load_next;
            } OC2FE_IC2PSC0;
            struct {
                logic next;
                logic load_next;
            } OC2PE_IC2PSC1;
            struct {
                logic [2:0] next;
                logic load_next;
            } OC2M_IC2F;
            struct {
                logic next;
                logic load_next;
            } OC2CE_IC2F3;
        } TIMx_CCMR1;
        struct {
            struct {
                logic next;
                logic load_next;
            } CC1E;
            struct {
                logic next;
                logic load_next;
            } CC1P;
            struct {
                logic next;
                logic load_next;
            } CC1NP;
            struct {
                logic next;
                logic load_next;
            } CC2E;
            struct {
                logic next;
                logic load_next;
            } CC2P;
            struct {
                logic next;
                logic load_next;
            } CC2NP;
            struct {
                logic next;
                logic load_next;
            } CC3E;
            struct {
                logic next;
                logic load_next;
            } CC3P;
            struct {
                logic next;
                logic load_next;
            } CC3NP;
            struct {
                logic next;
                logic load_next;
            } CC4E;
            struct {
                logic next;
                logic load_next;
            } CC4P;
            struct {
                logic next;
                logic load_next;
            } CC4NP;
        } TIMx_CCER;
        struct {
            struct {
                logic [31:0] next;
                logic load_next;
            } CNT;
        } TIM_CNT;
        struct {
            struct {
                logic [31:0] next;
                logic load_next;
            } PSC;
        } TIM_PSC;
        struct {
            struct {
                logic [31:0] next;
                logic load_next;
            } ARR;
        } TIM_ARR;
        struct {
            struct {
                logic [31:0] next;
                logic load_next;
            } CCR1;
        } TIM_CCR1;
    } field_combo_t;
    field_combo_t field_combo;

    typedef struct {
        struct {
            struct {
                logic value;
            } CEN;
            struct {
                logic value;
            } URS;
            struct {
                logic value;
            } OPM;
            struct {
                logic value;
            } DIR;
            struct {
                logic [1:0] value;
            } CMS;
            struct {
                logic value;
            } APRE;
            struct {
                logic [1:0] value;
            } CKD;
        } TIM_CR1;
        struct {
            struct {
                logic value;
            } CCDS;
            struct {
                logic [2:0] value;
            } MMS;
            struct {
                logic value;
            } T11S;
        } TIM_CR2;
        struct {
            struct {
                logic [2:0] value;
            } SMS;
            struct {
                logic [2:0] value;
            } TS;
            struct {
                logic value;
            } MSM;
            struct {
                logic [3:0] value;
            } ETF;
            struct {
                logic [1:0] value;
            } ETPS;
            struct {
                logic value;
            } ECE;
            struct {
                logic value;
            } ETP;
        } TIM_SMCR;
        struct {
            struct {
                logic value;
            } UIE;
            struct {
                logic value;
            } CC1IE;
            struct {
                logic value;
            } CC2IE;
            struct {
                logic value;
            } CC3IE;
            struct {
                logic value;
            } CC4IE;
            struct {
                logic value;
            } TIE;
            struct {
                logic value;
            } UDE;
            struct {
                logic value;
            } CC1DE;
            struct {
                logic value;
            } CC2DE;
            struct {
                logic value;
            } CC3DE;
            struct {
                logic value;
            } CC4DE;
            struct {
                logic value;
            } TDE;
        } TIMx_DIER;
        struct {
            struct {
                logic value;
            } UIF;
            struct {
                logic value;
            } CC1IF;
            struct {
                logic value;
            } CC2IF;
            struct {
                logic value;
            } CC3IF;
            struct {
                logic value;
            } CC4IF;
            struct {
                logic value;
            } TIF;
            struct {
                logic value;
            } CC1OF;
            struct {
                logic value;
            } CC2OF;
            struct {
                logic value;
            } CC3OF;
            struct {
                logic value;
            } CC4OF;
        } TIMx_SR;
        struct {
            struct {
                logic value;
            } UG;
            struct {
                logic value;
            } CC1G;
            struct {
                logic value;
            } CC2G;
            struct {
                logic value;
            } CC3G;
            struct {
                logic value;
            } CC4G;
            struct {
                logic value;
            } TG;
        } TIMx_EGR;
        struct {
            struct {
                logic [1:0] value;
            } CC1S;
            struct {
                logic value;
            } OC1FE_IC1PSC0;
            struct {
                logic value;
            } OC1PE_IC1PSC1;
            struct {
                logic [2:0] value;
            } OC1M_IC1F;
            struct {
                logic value;
            } OC1CE_IC1F3;
            struct {
                logic [1:0] value;
            } CC2S;
            struct {
                logic value;
            } OC2FE_IC2PSC0;
            struct {
                logic value;
            } OC2PE_IC2PSC1;
            struct {
                logic [2:0] value;
            } OC2M_IC2F;
            struct {
                logic value;
            } OC2CE_IC2F3;
        } TIMx_CCMR1;
        struct {
            struct {
                logic value;
            } CC1E;
            struct {
                logic value;
            } CC1P;
            struct {
                logic value;
            } CC1NP;
            struct {
                logic value;
            } CC2E;
            struct {
                logic value;
            } CC2P;
            struct {
                logic value;
            } CC2NP;
            struct {
                logic value;
            } CC3E;
            struct {
                logic value;
            } CC3P;
            struct {
                logic value;
            } CC3NP;
            struct {
                logic value;
            } CC4E;
            struct {
                logic value;
            } CC4P;
            struct {
                logic value;
            } CC4NP;
        } TIMx_CCER;
        struct {
            struct {
                logic [31:0] value;
            } CNT;
        } TIM_CNT;
        struct {
            struct {
                logic [31:0] value;
            } PSC;
        } TIM_PSC;
        struct {
            struct {
                logic [31:0] value;
            } ARR;
        } TIM_ARR;
        struct {
            struct {
                logic [31:0] value;
            } CCR1;
        } TIM_CCR1;
    } field_storage_t;
    field_storage_t field_storage;

    // Field: CSR_GPT.TIM_CR1.CEN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_CR1.CEN.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_CR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_CR1.CEN.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIM_CR1.CEN.next;
            load_next_c = '1;
        end
        field_combo.TIM_CR1.CEN.next = next_c;
        field_combo.TIM_CR1.CEN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_CR1.CEN.load_next) begin
            field_storage.TIM_CR1.CEN.value <= field_combo.TIM_CR1.CEN.next;
        end
    end
    assign hwif_out.TIM_CR1.CEN.value = field_storage.TIM_CR1.CEN.value;
    // Field: CSR_GPT.TIM_CR1.URS
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_CR1.URS.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_CR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_CR1.URS.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
            load_next_c = '1;
        end
        field_combo.TIM_CR1.URS.next = next_c;
        field_combo.TIM_CR1.URS.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_CR1.URS.load_next) begin
            field_storage.TIM_CR1.URS.value <= field_combo.TIM_CR1.URS.next;
        end
    end
    assign hwif_out.TIM_CR1.URS.value = field_storage.TIM_CR1.URS.value;
    // Field: CSR_GPT.TIM_CR1.OPM
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_CR1.OPM.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_CR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_CR1.OPM.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
            load_next_c = '1;
        end
        field_combo.TIM_CR1.OPM.next = next_c;
        field_combo.TIM_CR1.OPM.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_CR1.OPM.load_next) begin
            field_storage.TIM_CR1.OPM.value <= field_combo.TIM_CR1.OPM.next;
        end
    end
    assign hwif_out.TIM_CR1.OPM.value = field_storage.TIM_CR1.OPM.value;
    // Field: CSR_GPT.TIM_CR1.DIR
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_CR1.DIR.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_CR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_CR1.DIR.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
            load_next_c = '1;
        end
        field_combo.TIM_CR1.DIR.next = next_c;
        field_combo.TIM_CR1.DIR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_CR1.DIR.load_next) begin
            field_storage.TIM_CR1.DIR.value <= field_combo.TIM_CR1.DIR.next;
        end
    end
    assign hwif_out.TIM_CR1.DIR.value = field_storage.TIM_CR1.DIR.value;
    // Field: CSR_GPT.TIM_CR1.CMS
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_CR1.CMS.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_CR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_CR1.CMS.value & ~decoded_wr_biten[6:5]) | (decoded_wr_data[6:5] & decoded_wr_biten[6:5]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIM_CR1.CMS.next;
            load_next_c = '1;
        end
        field_combo.TIM_CR1.CMS.next = next_c;
        field_combo.TIM_CR1.CMS.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_CR1.CMS.load_next) begin
            field_storage.TIM_CR1.CMS.value <= field_combo.TIM_CR1.CMS.next;
        end
    end
    assign hwif_out.TIM_CR1.CMS.value = field_storage.TIM_CR1.CMS.value;
    // Field: CSR_GPT.TIM_CR1.APRE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_CR1.APRE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_CR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_CR1.APRE.value & ~decoded_wr_biten[7:7]) | (decoded_wr_data[7:7] & decoded_wr_biten[7:7]);
            load_next_c = '1;
        end
        field_combo.TIM_CR1.APRE.next = next_c;
        field_combo.TIM_CR1.APRE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_CR1.APRE.load_next) begin
            field_storage.TIM_CR1.APRE.value <= field_combo.TIM_CR1.APRE.next;
        end
    end
    assign hwif_out.TIM_CR1.APRE.value = field_storage.TIM_CR1.APRE.value;
    // Field: CSR_GPT.TIM_CR1.CKD
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_CR1.CKD.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_CR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_CR1.CKD.value & ~decoded_wr_biten[9:8]) | (decoded_wr_data[9:8] & decoded_wr_biten[9:8]);
            load_next_c = '1;
        end
        field_combo.TIM_CR1.CKD.next = next_c;
        field_combo.TIM_CR1.CKD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_CR1.CKD.load_next) begin
            field_storage.TIM_CR1.CKD.value <= field_combo.TIM_CR1.CKD.next;
        end
    end
    assign hwif_out.TIM_CR1.CKD.value = field_storage.TIM_CR1.CKD.value;
    assign hwif_out.TIM_CR2.RESERVED_2_0.value = 3'h0;
    // Field: CSR_GPT.TIM_CR2.CCDS
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_CR2.CCDS.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_CR2 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_CR2.CCDS.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
            load_next_c = '1;
        end
        field_combo.TIM_CR2.CCDS.next = next_c;
        field_combo.TIM_CR2.CCDS.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_CR2.CCDS.load_next) begin
            field_storage.TIM_CR2.CCDS.value <= field_combo.TIM_CR2.CCDS.next;
        end
    end
    assign hwif_out.TIM_CR2.CCDS.value = field_storage.TIM_CR2.CCDS.value;
    // Field: CSR_GPT.TIM_CR2.MMS
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_CR2.MMS.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_CR2 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_CR2.MMS.value & ~decoded_wr_biten[6:4]) | (decoded_wr_data[6:4] & decoded_wr_biten[6:4]);
            load_next_c = '1;
        end
        field_combo.TIM_CR2.MMS.next = next_c;
        field_combo.TIM_CR2.MMS.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_CR2.MMS.load_next) begin
            field_storage.TIM_CR2.MMS.value <= field_combo.TIM_CR2.MMS.next;
        end
    end
    assign hwif_out.TIM_CR2.MMS.value = field_storage.TIM_CR2.MMS.value;
    // Field: CSR_GPT.TIM_CR2.T11S
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_CR2.T11S.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_CR2 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_CR2.T11S.value & ~decoded_wr_biten[7:7]) | (decoded_wr_data[7:7] & decoded_wr_biten[7:7]);
            load_next_c = '1;
        end
        field_combo.TIM_CR2.T11S.next = next_c;
        field_combo.TIM_CR2.T11S.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_CR2.T11S.load_next) begin
            field_storage.TIM_CR2.T11S.value <= field_combo.TIM_CR2.T11S.next;
        end
    end
    assign hwif_out.TIM_CR2.T11S.value = field_storage.TIM_CR2.T11S.value;
    assign hwif_out.TIM_CR2.RESERVED_15_8.value = 8'h0;
    // Field: CSR_GPT.TIM_SMCR.SMS
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_SMCR.SMS.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_SMCR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_SMCR.SMS.value & ~decoded_wr_biten[2:0]) | (decoded_wr_data[2:0] & decoded_wr_biten[2:0]);
            load_next_c = '1;
        end
        field_combo.TIM_SMCR.SMS.next = next_c;
        field_combo.TIM_SMCR.SMS.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_SMCR.SMS.load_next) begin
            field_storage.TIM_SMCR.SMS.value <= field_combo.TIM_SMCR.SMS.next;
        end
    end
    assign hwif_out.TIM_SMCR.SMS.value = field_storage.TIM_SMCR.SMS.value;
    assign hwif_out.TIM_SMCR.RESERVED.value = 1'h0;
    // Field: CSR_GPT.TIM_SMCR.TS
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_SMCR.TS.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_SMCR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_SMCR.TS.value & ~decoded_wr_biten[6:4]) | (decoded_wr_data[6:4] & decoded_wr_biten[6:4]);
            load_next_c = '1;
        end
        field_combo.TIM_SMCR.TS.next = next_c;
        field_combo.TIM_SMCR.TS.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_SMCR.TS.load_next) begin
            field_storage.TIM_SMCR.TS.value <= field_combo.TIM_SMCR.TS.next;
        end
    end
    assign hwif_out.TIM_SMCR.TS.value = field_storage.TIM_SMCR.TS.value;
    // Field: CSR_GPT.TIM_SMCR.MSM
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_SMCR.MSM.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_SMCR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_SMCR.MSM.value & ~decoded_wr_biten[7:7]) | (decoded_wr_data[7:7] & decoded_wr_biten[7:7]);
            load_next_c = '1;
        end
        field_combo.TIM_SMCR.MSM.next = next_c;
        field_combo.TIM_SMCR.MSM.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_SMCR.MSM.load_next) begin
            field_storage.TIM_SMCR.MSM.value <= field_combo.TIM_SMCR.MSM.next;
        end
    end
    assign hwif_out.TIM_SMCR.MSM.value = field_storage.TIM_SMCR.MSM.value;
    // Field: CSR_GPT.TIM_SMCR.ETF
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_SMCR.ETF.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_SMCR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_SMCR.ETF.value & ~decoded_wr_biten[11:8]) | (decoded_wr_data[11:8] & decoded_wr_biten[11:8]);
            load_next_c = '1;
        end
        field_combo.TIM_SMCR.ETF.next = next_c;
        field_combo.TIM_SMCR.ETF.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_SMCR.ETF.load_next) begin
            field_storage.TIM_SMCR.ETF.value <= field_combo.TIM_SMCR.ETF.next;
        end
    end
    assign hwif_out.TIM_SMCR.ETF.value = field_storage.TIM_SMCR.ETF.value;
    // Field: CSR_GPT.TIM_SMCR.ETPS
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_SMCR.ETPS.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_SMCR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_SMCR.ETPS.value & ~decoded_wr_biten[13:12]) | (decoded_wr_data[13:12] & decoded_wr_biten[13:12]);
            load_next_c = '1;
        end
        field_combo.TIM_SMCR.ETPS.next = next_c;
        field_combo.TIM_SMCR.ETPS.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_SMCR.ETPS.load_next) begin
            field_storage.TIM_SMCR.ETPS.value <= field_combo.TIM_SMCR.ETPS.next;
        end
    end
    assign hwif_out.TIM_SMCR.ETPS.value = field_storage.TIM_SMCR.ETPS.value;
    // Field: CSR_GPT.TIM_SMCR.ECE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_SMCR.ECE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_SMCR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_SMCR.ECE.value & ~decoded_wr_biten[14:14]) | (decoded_wr_data[14:14] & decoded_wr_biten[14:14]);
            load_next_c = '1;
        end
        field_combo.TIM_SMCR.ECE.next = next_c;
        field_combo.TIM_SMCR.ECE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_SMCR.ECE.load_next) begin
            field_storage.TIM_SMCR.ECE.value <= field_combo.TIM_SMCR.ECE.next;
        end
    end
    assign hwif_out.TIM_SMCR.ECE.value = field_storage.TIM_SMCR.ECE.value;
    // Field: CSR_GPT.TIM_SMCR.ETP
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_SMCR.ETP.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_SMCR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_SMCR.ETP.value & ~decoded_wr_biten[15:15]) | (decoded_wr_data[15:15] & decoded_wr_biten[15:15]);
            load_next_c = '1;
        end
        field_combo.TIM_SMCR.ETP.next = next_c;
        field_combo.TIM_SMCR.ETP.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_SMCR.ETP.load_next) begin
            field_storage.TIM_SMCR.ETP.value <= field_combo.TIM_SMCR.ETP.next;
        end
    end
    assign hwif_out.TIM_SMCR.ETP.value = field_storage.TIM_SMCR.ETP.value;
    // Field: CSR_GPT.TIMx_DIER.UIE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_DIER.UIE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_DIER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_DIER.UIE.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_DIER.UIE.next;
            load_next_c = '1;
        end
        field_combo.TIMx_DIER.UIE.next = next_c;
        field_combo.TIMx_DIER.UIE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_DIER.UIE.load_next) begin
            field_storage.TIMx_DIER.UIE.value <= field_combo.TIMx_DIER.UIE.next;
        end
    end
    assign hwif_out.TIMx_DIER.UIE.value = field_storage.TIMx_DIER.UIE.value;
    // Field: CSR_GPT.TIMx_DIER.CC1IE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_DIER.CC1IE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_DIER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_DIER.CC1IE.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_DIER.CC1IE.next;
            load_next_c = '1;
        end
        field_combo.TIMx_DIER.CC1IE.next = next_c;
        field_combo.TIMx_DIER.CC1IE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_DIER.CC1IE.load_next) begin
            field_storage.TIMx_DIER.CC1IE.value <= field_combo.TIMx_DIER.CC1IE.next;
        end
    end
    assign hwif_out.TIMx_DIER.CC1IE.value = field_storage.TIMx_DIER.CC1IE.value;
    // Field: CSR_GPT.TIMx_DIER.CC2IE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_DIER.CC2IE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_DIER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_DIER.CC2IE.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_DIER.CC2IE.next;
            load_next_c = '1;
        end
        field_combo.TIMx_DIER.CC2IE.next = next_c;
        field_combo.TIMx_DIER.CC2IE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_DIER.CC2IE.load_next) begin
            field_storage.TIMx_DIER.CC2IE.value <= field_combo.TIMx_DIER.CC2IE.next;
        end
    end
    assign hwif_out.TIMx_DIER.CC2IE.value = field_storage.TIMx_DIER.CC2IE.value;
    // Field: CSR_GPT.TIMx_DIER.CC3IE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_DIER.CC3IE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_DIER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_DIER.CC3IE.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_DIER.CC3IE.next;
            load_next_c = '1;
        end
        field_combo.TIMx_DIER.CC3IE.next = next_c;
        field_combo.TIMx_DIER.CC3IE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_DIER.CC3IE.load_next) begin
            field_storage.TIMx_DIER.CC3IE.value <= field_combo.TIMx_DIER.CC3IE.next;
        end
    end
    assign hwif_out.TIMx_DIER.CC3IE.value = field_storage.TIMx_DIER.CC3IE.value;
    // Field: CSR_GPT.TIMx_DIER.CC4IE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_DIER.CC4IE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_DIER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_DIER.CC4IE.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_DIER.CC4IE.next;
            load_next_c = '1;
        end
        field_combo.TIMx_DIER.CC4IE.next = next_c;
        field_combo.TIMx_DIER.CC4IE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_DIER.CC4IE.load_next) begin
            field_storage.TIMx_DIER.CC4IE.value <= field_combo.TIMx_DIER.CC4IE.next;
        end
    end
    assign hwif_out.TIMx_DIER.CC4IE.value = field_storage.TIMx_DIER.CC4IE.value;
    assign hwif_out.TIMx_DIER.reserved_5.value = 1'h0;
    // Field: CSR_GPT.TIMx_DIER.TIE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_DIER.TIE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_DIER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_DIER.TIE.value & ~decoded_wr_biten[6:6]) | (decoded_wr_data[6:6] & decoded_wr_biten[6:6]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_DIER.TIE.next;
            load_next_c = '1;
        end
        field_combo.TIMx_DIER.TIE.next = next_c;
        field_combo.TIMx_DIER.TIE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_DIER.TIE.load_next) begin
            field_storage.TIMx_DIER.TIE.value <= field_combo.TIMx_DIER.TIE.next;
        end
    end
    assign hwif_out.TIMx_DIER.TIE.value = field_storage.TIMx_DIER.TIE.value;
    assign hwif_out.TIMx_DIER.reserved_7.value = 1'h0;
    // Field: CSR_GPT.TIMx_DIER.UDE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_DIER.UDE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_DIER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_DIER.UDE.value & ~decoded_wr_biten[8:8]) | (decoded_wr_data[8:8] & decoded_wr_biten[8:8]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_DIER.UDE.next;
            load_next_c = '1;
        end
        field_combo.TIMx_DIER.UDE.next = next_c;
        field_combo.TIMx_DIER.UDE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_DIER.UDE.load_next) begin
            field_storage.TIMx_DIER.UDE.value <= field_combo.TIMx_DIER.UDE.next;
        end
    end
    assign hwif_out.TIMx_DIER.UDE.value = field_storage.TIMx_DIER.UDE.value;
    // Field: CSR_GPT.TIMx_DIER.CC1DE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_DIER.CC1DE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_DIER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_DIER.CC1DE.value & ~decoded_wr_biten[9:9]) | (decoded_wr_data[9:9] & decoded_wr_biten[9:9]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_DIER.CC1DE.next;
            load_next_c = '1;
        end
        field_combo.TIMx_DIER.CC1DE.next = next_c;
        field_combo.TIMx_DIER.CC1DE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_DIER.CC1DE.load_next) begin
            field_storage.TIMx_DIER.CC1DE.value <= field_combo.TIMx_DIER.CC1DE.next;
        end
    end
    assign hwif_out.TIMx_DIER.CC1DE.value = field_storage.TIMx_DIER.CC1DE.value;
    // Field: CSR_GPT.TIMx_DIER.CC2DE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_DIER.CC2DE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_DIER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_DIER.CC2DE.value & ~decoded_wr_biten[10:10]) | (decoded_wr_data[10:10] & decoded_wr_biten[10:10]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_DIER.CC2DE.next;
            load_next_c = '1;
        end
        field_combo.TIMx_DIER.CC2DE.next = next_c;
        field_combo.TIMx_DIER.CC2DE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_DIER.CC2DE.load_next) begin
            field_storage.TIMx_DIER.CC2DE.value <= field_combo.TIMx_DIER.CC2DE.next;
        end
    end
    assign hwif_out.TIMx_DIER.CC2DE.value = field_storage.TIMx_DIER.CC2DE.value;
    // Field: CSR_GPT.TIMx_DIER.CC3DE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_DIER.CC3DE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_DIER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_DIER.CC3DE.value & ~decoded_wr_biten[11:11]) | (decoded_wr_data[11:11] & decoded_wr_biten[11:11]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_DIER.CC3DE.next;
            load_next_c = '1;
        end
        field_combo.TIMx_DIER.CC3DE.next = next_c;
        field_combo.TIMx_DIER.CC3DE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_DIER.CC3DE.load_next) begin
            field_storage.TIMx_DIER.CC3DE.value <= field_combo.TIMx_DIER.CC3DE.next;
        end
    end
    assign hwif_out.TIMx_DIER.CC3DE.value = field_storage.TIMx_DIER.CC3DE.value;
    // Field: CSR_GPT.TIMx_DIER.CC4DE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_DIER.CC4DE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_DIER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_DIER.CC4DE.value & ~decoded_wr_biten[12:12]) | (decoded_wr_data[12:12] & decoded_wr_biten[12:12]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_DIER.CC4DE.next;
            load_next_c = '1;
        end
        field_combo.TIMx_DIER.CC4DE.next = next_c;
        field_combo.TIMx_DIER.CC4DE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_DIER.CC4DE.load_next) begin
            field_storage.TIMx_DIER.CC4DE.value <= field_combo.TIMx_DIER.CC4DE.next;
        end
    end
    assign hwif_out.TIMx_DIER.CC4DE.value = field_storage.TIMx_DIER.CC4DE.value;
    assign hwif_out.TIMx_DIER.reserved_13.value = 1'h0;
    // Field: CSR_GPT.TIMx_DIER.TDE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_DIER.TDE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_DIER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_DIER.TDE.value & ~decoded_wr_biten[14:14]) | (decoded_wr_data[14:14] & decoded_wr_biten[14:14]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_DIER.TDE.next;
            load_next_c = '1;
        end
        field_combo.TIMx_DIER.TDE.next = next_c;
        field_combo.TIMx_DIER.TDE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_DIER.TDE.load_next) begin
            field_storage.TIMx_DIER.TDE.value <= field_combo.TIMx_DIER.TDE.next;
        end
    end
    assign hwif_out.TIMx_DIER.TDE.value = field_storage.TIMx_DIER.TDE.value;
    assign hwif_out.TIMx_DIER.reserved_15.value = 1'h0;
    // Field: CSR_GPT.TIMx_SR.UIF
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_SR.UIF.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_SR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_SR.UIF.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_SR.UIF.next;
            load_next_c = '1;
        end
        field_combo.TIMx_SR.UIF.next = next_c;
        field_combo.TIMx_SR.UIF.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_SR.UIF.load_next) begin
            field_storage.TIMx_SR.UIF.value <= field_combo.TIMx_SR.UIF.next;
        end
    end
    assign hwif_out.TIMx_SR.UIF.value = field_storage.TIMx_SR.UIF.value;
    // Field: CSR_GPT.TIMx_SR.CC1IF
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_SR.CC1IF.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_SR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_SR.CC1IF.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_SR.CC1IF.next;
            load_next_c = '1;
        end
        field_combo.TIMx_SR.CC1IF.next = next_c;
        field_combo.TIMx_SR.CC1IF.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_SR.CC1IF.load_next) begin
            field_storage.TIMx_SR.CC1IF.value <= field_combo.TIMx_SR.CC1IF.next;
        end
    end
    assign hwif_out.TIMx_SR.CC1IF.value = field_storage.TIMx_SR.CC1IF.value;
    // Field: CSR_GPT.TIMx_SR.CC2IF
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_SR.CC2IF.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_SR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_SR.CC2IF.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_SR.CC2IF.next;
            load_next_c = '1;
        end
        field_combo.TIMx_SR.CC2IF.next = next_c;
        field_combo.TIMx_SR.CC2IF.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_SR.CC2IF.load_next) begin
            field_storage.TIMx_SR.CC2IF.value <= field_combo.TIMx_SR.CC2IF.next;
        end
    end
    assign hwif_out.TIMx_SR.CC2IF.value = field_storage.TIMx_SR.CC2IF.value;
    // Field: CSR_GPT.TIMx_SR.CC3IF
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_SR.CC3IF.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_SR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_SR.CC3IF.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_SR.CC3IF.next;
            load_next_c = '1;
        end
        field_combo.TIMx_SR.CC3IF.next = next_c;
        field_combo.TIMx_SR.CC3IF.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_SR.CC3IF.load_next) begin
            field_storage.TIMx_SR.CC3IF.value <= field_combo.TIMx_SR.CC3IF.next;
        end
    end
    assign hwif_out.TIMx_SR.CC3IF.value = field_storage.TIMx_SR.CC3IF.value;
    // Field: CSR_GPT.TIMx_SR.CC4IF
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_SR.CC4IF.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_SR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_SR.CC4IF.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_SR.CC4IF.next;
            load_next_c = '1;
        end
        field_combo.TIMx_SR.CC4IF.next = next_c;
        field_combo.TIMx_SR.CC4IF.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_SR.CC4IF.load_next) begin
            field_storage.TIMx_SR.CC4IF.value <= field_combo.TIMx_SR.CC4IF.next;
        end
    end
    assign hwif_out.TIMx_SR.CC4IF.value = field_storage.TIMx_SR.CC4IF.value;
    assign hwif_out.TIMx_SR.reserved_5.value = 1'h0;
    // Field: CSR_GPT.TIMx_SR.TIF
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_SR.TIF.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_SR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_SR.TIF.value & ~decoded_wr_biten[6:6]) | (decoded_wr_data[6:6] & decoded_wr_biten[6:6]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_SR.TIF.next;
            load_next_c = '1;
        end
        field_combo.TIMx_SR.TIF.next = next_c;
        field_combo.TIMx_SR.TIF.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_SR.TIF.load_next) begin
            field_storage.TIMx_SR.TIF.value <= field_combo.TIMx_SR.TIF.next;
        end
    end
    assign hwif_out.TIMx_SR.TIF.value = field_storage.TIMx_SR.TIF.value;
    assign hwif_out.TIMx_SR.reserved_8_7.value = 2'h0;
    // Field: CSR_GPT.TIMx_SR.CC1OF
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_SR.CC1OF.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_SR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_SR.CC1OF.value & ~decoded_wr_biten[9:9]) | (decoded_wr_data[9:9] & decoded_wr_biten[9:9]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_SR.CC1OF.next;
            load_next_c = '1;
        end
        field_combo.TIMx_SR.CC1OF.next = next_c;
        field_combo.TIMx_SR.CC1OF.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_SR.CC1OF.load_next) begin
            field_storage.TIMx_SR.CC1OF.value <= field_combo.TIMx_SR.CC1OF.next;
        end
    end
    assign hwif_out.TIMx_SR.CC1OF.value = field_storage.TIMx_SR.CC1OF.value;
    // Field: CSR_GPT.TIMx_SR.CC2OF
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_SR.CC2OF.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_SR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_SR.CC2OF.value & ~decoded_wr_biten[10:10]) | (decoded_wr_data[10:10] & decoded_wr_biten[10:10]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_SR.CC2OF.next;
            load_next_c = '1;
        end
        field_combo.TIMx_SR.CC2OF.next = next_c;
        field_combo.TIMx_SR.CC2OF.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_SR.CC2OF.load_next) begin
            field_storage.TIMx_SR.CC2OF.value <= field_combo.TIMx_SR.CC2OF.next;
        end
    end
    assign hwif_out.TIMx_SR.CC2OF.value = field_storage.TIMx_SR.CC2OF.value;
    // Field: CSR_GPT.TIMx_SR.CC3OF
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_SR.CC3OF.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_SR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_SR.CC3OF.value & ~decoded_wr_biten[11:11]) | (decoded_wr_data[11:11] & decoded_wr_biten[11:11]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_SR.CC3OF.next;
            load_next_c = '1;
        end
        field_combo.TIMx_SR.CC3OF.next = next_c;
        field_combo.TIMx_SR.CC3OF.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_SR.CC3OF.load_next) begin
            field_storage.TIMx_SR.CC3OF.value <= field_combo.TIMx_SR.CC3OF.next;
        end
    end
    assign hwif_out.TIMx_SR.CC3OF.value = field_storage.TIMx_SR.CC3OF.value;
    // Field: CSR_GPT.TIMx_SR.CC4OF
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_SR.CC4OF.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_SR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_SR.CC4OF.value & ~decoded_wr_biten[12:12]) | (decoded_wr_data[12:12] & decoded_wr_biten[12:12]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_SR.CC4OF.next;
            load_next_c = '1;
        end
        field_combo.TIMx_SR.CC4OF.next = next_c;
        field_combo.TIMx_SR.CC4OF.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_SR.CC4OF.load_next) begin
            field_storage.TIMx_SR.CC4OF.value <= field_combo.TIMx_SR.CC4OF.next;
        end
    end
    assign hwif_out.TIMx_SR.CC4OF.value = field_storage.TIMx_SR.CC4OF.value;
    assign hwif_out.TIMx_SR.reserved_15_13.value = 3'h0;
    // Field: CSR_GPT.TIMx_EGR.UG
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_EGR.UG.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_EGR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_EGR.UG.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_EGR.UG.next;
            load_next_c = '1;
        end
        field_combo.TIMx_EGR.UG.next = next_c;
        field_combo.TIMx_EGR.UG.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_EGR.UG.load_next) begin
            field_storage.TIMx_EGR.UG.value <= field_combo.TIMx_EGR.UG.next;
        end
    end
    assign hwif_out.TIMx_EGR.UG.value = field_storage.TIMx_EGR.UG.value;
    // Field: CSR_GPT.TIMx_EGR.CC1G
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_EGR.CC1G.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_EGR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_EGR.CC1G.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_EGR.CC1G.next;
            load_next_c = '1;
        end
        field_combo.TIMx_EGR.CC1G.next = next_c;
        field_combo.TIMx_EGR.CC1G.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_EGR.CC1G.load_next) begin
            field_storage.TIMx_EGR.CC1G.value <= field_combo.TIMx_EGR.CC1G.next;
        end
    end
    assign hwif_out.TIMx_EGR.CC1G.value = field_storage.TIMx_EGR.CC1G.value;
    // Field: CSR_GPT.TIMx_EGR.CC2G
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_EGR.CC2G.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_EGR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_EGR.CC2G.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_EGR.CC2G.next;
            load_next_c = '1;
        end
        field_combo.TIMx_EGR.CC2G.next = next_c;
        field_combo.TIMx_EGR.CC2G.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_EGR.CC2G.load_next) begin
            field_storage.TIMx_EGR.CC2G.value <= field_combo.TIMx_EGR.CC2G.next;
        end
    end
    assign hwif_out.TIMx_EGR.CC2G.value = field_storage.TIMx_EGR.CC2G.value;
    // Field: CSR_GPT.TIMx_EGR.CC3G
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_EGR.CC3G.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_EGR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_EGR.CC3G.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_EGR.CC3G.next;
            load_next_c = '1;
        end
        field_combo.TIMx_EGR.CC3G.next = next_c;
        field_combo.TIMx_EGR.CC3G.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_EGR.CC3G.load_next) begin
            field_storage.TIMx_EGR.CC3G.value <= field_combo.TIMx_EGR.CC3G.next;
        end
    end
    assign hwif_out.TIMx_EGR.CC3G.value = field_storage.TIMx_EGR.CC3G.value;
    // Field: CSR_GPT.TIMx_EGR.CC4G
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_EGR.CC4G.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_EGR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_EGR.CC4G.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_EGR.CC4G.next;
            load_next_c = '1;
        end
        field_combo.TIMx_EGR.CC4G.next = next_c;
        field_combo.TIMx_EGR.CC4G.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_EGR.CC4G.load_next) begin
            field_storage.TIMx_EGR.CC4G.value <= field_combo.TIMx_EGR.CC4G.next;
        end
    end
    assign hwif_out.TIMx_EGR.CC4G.value = field_storage.TIMx_EGR.CC4G.value;
    assign hwif_out.TIMx_EGR.reserved_5.value = 1'h0;
    // Field: CSR_GPT.TIMx_EGR.TG
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_EGR.TG.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_EGR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_EGR.TG.value & ~decoded_wr_biten[6:6]) | (decoded_wr_data[6:6] & decoded_wr_biten[6:6]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_EGR.TG.next;
            load_next_c = '1;
        end
        field_combo.TIMx_EGR.TG.next = next_c;
        field_combo.TIMx_EGR.TG.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_EGR.TG.load_next) begin
            field_storage.TIMx_EGR.TG.value <= field_combo.TIMx_EGR.TG.next;
        end
    end
    assign hwif_out.TIMx_EGR.TG.value = field_storage.TIMx_EGR.TG.value;
    assign hwif_out.TIMx_EGR.reserved_15_7.value = 9'h0;
    // Field: CSR_GPT.TIMx_CCMR1.CC1S
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCMR1.CC1S.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCMR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCMR1.CC1S.value & ~decoded_wr_biten[1:0]) | (decoded_wr_data[1:0] & decoded_wr_biten[1:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCMR1.CC1S.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCMR1.CC1S.next = next_c;
        field_combo.TIMx_CCMR1.CC1S.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCMR1.CC1S.load_next) begin
            field_storage.TIMx_CCMR1.CC1S.value <= field_combo.TIMx_CCMR1.CC1S.next;
        end
    end
    assign hwif_out.TIMx_CCMR1.CC1S.value = field_storage.TIMx_CCMR1.CC1S.value;
    // Field: CSR_GPT.TIMx_CCMR1.OC1FE_IC1PSC0
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCMR1.OC1FE_IC1PSC0.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCMR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCMR1.OC1FE_IC1PSC0.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCMR1.OC1FE_IC1PSC0.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCMR1.OC1FE_IC1PSC0.next = next_c;
        field_combo.TIMx_CCMR1.OC1FE_IC1PSC0.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCMR1.OC1FE_IC1PSC0.load_next) begin
            field_storage.TIMx_CCMR1.OC1FE_IC1PSC0.value <= field_combo.TIMx_CCMR1.OC1FE_IC1PSC0.next;
        end
    end
    assign hwif_out.TIMx_CCMR1.OC1FE_IC1PSC0.value = field_storage.TIMx_CCMR1.OC1FE_IC1PSC0.value;
    // Field: CSR_GPT.TIMx_CCMR1.OC1PE_IC1PSC1
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCMR1.OC1PE_IC1PSC1.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCMR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCMR1.OC1PE_IC1PSC1.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCMR1.OC1PE_IC1PSC1.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCMR1.OC1PE_IC1PSC1.next = next_c;
        field_combo.TIMx_CCMR1.OC1PE_IC1PSC1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCMR1.OC1PE_IC1PSC1.load_next) begin
            field_storage.TIMx_CCMR1.OC1PE_IC1PSC1.value <= field_combo.TIMx_CCMR1.OC1PE_IC1PSC1.next;
        end
    end
    assign hwif_out.TIMx_CCMR1.OC1PE_IC1PSC1.value = field_storage.TIMx_CCMR1.OC1PE_IC1PSC1.value;
    // Field: CSR_GPT.TIMx_CCMR1.OC1M_IC1F
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCMR1.OC1M_IC1F.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCMR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCMR1.OC1M_IC1F.value & ~decoded_wr_biten[6:4]) | (decoded_wr_data[6:4] & decoded_wr_biten[6:4]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCMR1.OC1M_IC1F.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCMR1.OC1M_IC1F.next = next_c;
        field_combo.TIMx_CCMR1.OC1M_IC1F.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCMR1.OC1M_IC1F.load_next) begin
            field_storage.TIMx_CCMR1.OC1M_IC1F.value <= field_combo.TIMx_CCMR1.OC1M_IC1F.next;
        end
    end
    assign hwif_out.TIMx_CCMR1.OC1M_IC1F.value = field_storage.TIMx_CCMR1.OC1M_IC1F.value;
    // Field: CSR_GPT.TIMx_CCMR1.OC1CE_IC1F3
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCMR1.OC1CE_IC1F3.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCMR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCMR1.OC1CE_IC1F3.value & ~decoded_wr_biten[7:7]) | (decoded_wr_data[7:7] & decoded_wr_biten[7:7]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCMR1.OC1CE_IC1F3.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCMR1.OC1CE_IC1F3.next = next_c;
        field_combo.TIMx_CCMR1.OC1CE_IC1F3.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCMR1.OC1CE_IC1F3.load_next) begin
            field_storage.TIMx_CCMR1.OC1CE_IC1F3.value <= field_combo.TIMx_CCMR1.OC1CE_IC1F3.next;
        end
    end
    assign hwif_out.TIMx_CCMR1.OC1CE_IC1F3.value = field_storage.TIMx_CCMR1.OC1CE_IC1F3.value;
    // Field: CSR_GPT.TIMx_CCMR1.CC2S
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCMR1.CC2S.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCMR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCMR1.CC2S.value & ~decoded_wr_biten[9:8]) | (decoded_wr_data[9:8] & decoded_wr_biten[9:8]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCMR1.CC2S.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCMR1.CC2S.next = next_c;
        field_combo.TIMx_CCMR1.CC2S.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCMR1.CC2S.load_next) begin
            field_storage.TIMx_CCMR1.CC2S.value <= field_combo.TIMx_CCMR1.CC2S.next;
        end
    end
    assign hwif_out.TIMx_CCMR1.CC2S.value = field_storage.TIMx_CCMR1.CC2S.value;
    // Field: CSR_GPT.TIMx_CCMR1.OC2FE_IC2PSC0
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCMR1.OC2FE_IC2PSC0.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCMR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCMR1.OC2FE_IC2PSC0.value & ~decoded_wr_biten[10:10]) | (decoded_wr_data[10:10] & decoded_wr_biten[10:10]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCMR1.OC2FE_IC2PSC0.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCMR1.OC2FE_IC2PSC0.next = next_c;
        field_combo.TIMx_CCMR1.OC2FE_IC2PSC0.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCMR1.OC2FE_IC2PSC0.load_next) begin
            field_storage.TIMx_CCMR1.OC2FE_IC2PSC0.value <= field_combo.TIMx_CCMR1.OC2FE_IC2PSC0.next;
        end
    end
    assign hwif_out.TIMx_CCMR1.OC2FE_IC2PSC0.value = field_storage.TIMx_CCMR1.OC2FE_IC2PSC0.value;
    // Field: CSR_GPT.TIMx_CCMR1.OC2PE_IC2PSC1
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCMR1.OC2PE_IC2PSC1.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCMR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCMR1.OC2PE_IC2PSC1.value & ~decoded_wr_biten[11:11]) | (decoded_wr_data[11:11] & decoded_wr_biten[11:11]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCMR1.OC2PE_IC2PSC1.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCMR1.OC2PE_IC2PSC1.next = next_c;
        field_combo.TIMx_CCMR1.OC2PE_IC2PSC1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCMR1.OC2PE_IC2PSC1.load_next) begin
            field_storage.TIMx_CCMR1.OC2PE_IC2PSC1.value <= field_combo.TIMx_CCMR1.OC2PE_IC2PSC1.next;
        end
    end
    assign hwif_out.TIMx_CCMR1.OC2PE_IC2PSC1.value = field_storage.TIMx_CCMR1.OC2PE_IC2PSC1.value;
    // Field: CSR_GPT.TIMx_CCMR1.OC2M_IC2F
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCMR1.OC2M_IC2F.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCMR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCMR1.OC2M_IC2F.value & ~decoded_wr_biten[14:12]) | (decoded_wr_data[14:12] & decoded_wr_biten[14:12]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCMR1.OC2M_IC2F.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCMR1.OC2M_IC2F.next = next_c;
        field_combo.TIMx_CCMR1.OC2M_IC2F.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCMR1.OC2M_IC2F.load_next) begin
            field_storage.TIMx_CCMR1.OC2M_IC2F.value <= field_combo.TIMx_CCMR1.OC2M_IC2F.next;
        end
    end
    assign hwif_out.TIMx_CCMR1.OC2M_IC2F.value = field_storage.TIMx_CCMR1.OC2M_IC2F.value;
    // Field: CSR_GPT.TIMx_CCMR1.OC2CE_IC2F3
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCMR1.OC2CE_IC2F3.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCMR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCMR1.OC2CE_IC2F3.value & ~decoded_wr_biten[15:15]) | (decoded_wr_data[15:15] & decoded_wr_biten[15:15]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCMR1.OC2CE_IC2F3.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCMR1.OC2CE_IC2F3.next = next_c;
        field_combo.TIMx_CCMR1.OC2CE_IC2F3.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCMR1.OC2CE_IC2F3.load_next) begin
            field_storage.TIMx_CCMR1.OC2CE_IC2F3.value <= field_combo.TIMx_CCMR1.OC2CE_IC2F3.next;
        end
    end
    assign hwif_out.TIMx_CCMR1.OC2CE_IC2F3.value = field_storage.TIMx_CCMR1.OC2CE_IC2F3.value;
    // Field: CSR_GPT.TIMx_CCER.CC1E
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCER.CC1E.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCER.CC1E.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCER.CC1E.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCER.CC1E.next = next_c;
        field_combo.TIMx_CCER.CC1E.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCER.CC1E.load_next) begin
            field_storage.TIMx_CCER.CC1E.value <= field_combo.TIMx_CCER.CC1E.next;
        end
    end
    assign hwif_out.TIMx_CCER.CC1E.value = field_storage.TIMx_CCER.CC1E.value;
    // Field: CSR_GPT.TIMx_CCER.CC1P
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCER.CC1P.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCER.CC1P.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCER.CC1P.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCER.CC1P.next = next_c;
        field_combo.TIMx_CCER.CC1P.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCER.CC1P.load_next) begin
            field_storage.TIMx_CCER.CC1P.value <= field_combo.TIMx_CCER.CC1P.next;
        end
    end
    assign hwif_out.TIMx_CCER.CC1P.value = field_storage.TIMx_CCER.CC1P.value;
    assign hwif_out.TIMx_CCER.reserved_2.value = 1'h0;
    // Field: CSR_GPT.TIMx_CCER.CC1NP
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCER.CC1NP.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCER.CC1NP.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCER.CC1NP.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCER.CC1NP.next = next_c;
        field_combo.TIMx_CCER.CC1NP.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCER.CC1NP.load_next) begin
            field_storage.TIMx_CCER.CC1NP.value <= field_combo.TIMx_CCER.CC1NP.next;
        end
    end
    assign hwif_out.TIMx_CCER.CC1NP.value = field_storage.TIMx_CCER.CC1NP.value;
    // Field: CSR_GPT.TIMx_CCER.CC2E
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCER.CC2E.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCER.CC2E.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCER.CC2E.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCER.CC2E.next = next_c;
        field_combo.TIMx_CCER.CC2E.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCER.CC2E.load_next) begin
            field_storage.TIMx_CCER.CC2E.value <= field_combo.TIMx_CCER.CC2E.next;
        end
    end
    assign hwif_out.TIMx_CCER.CC2E.value = field_storage.TIMx_CCER.CC2E.value;
    // Field: CSR_GPT.TIMx_CCER.CC2P
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCER.CC2P.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCER.CC2P.value & ~decoded_wr_biten[5:5]) | (decoded_wr_data[5:5] & decoded_wr_biten[5:5]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCER.CC2P.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCER.CC2P.next = next_c;
        field_combo.TIMx_CCER.CC2P.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCER.CC2P.load_next) begin
            field_storage.TIMx_CCER.CC2P.value <= field_combo.TIMx_CCER.CC2P.next;
        end
    end
    assign hwif_out.TIMx_CCER.CC2P.value = field_storage.TIMx_CCER.CC2P.value;
    assign hwif_out.TIMx_CCER.reserved_6.value = 1'h0;
    // Field: CSR_GPT.TIMx_CCER.CC2NP
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCER.CC2NP.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCER.CC2NP.value & ~decoded_wr_biten[7:7]) | (decoded_wr_data[7:7] & decoded_wr_biten[7:7]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCER.CC2NP.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCER.CC2NP.next = next_c;
        field_combo.TIMx_CCER.CC2NP.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCER.CC2NP.load_next) begin
            field_storage.TIMx_CCER.CC2NP.value <= field_combo.TIMx_CCER.CC2NP.next;
        end
    end
    assign hwif_out.TIMx_CCER.CC2NP.value = field_storage.TIMx_CCER.CC2NP.value;
    // Field: CSR_GPT.TIMx_CCER.CC3E
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCER.CC3E.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCER.CC3E.value & ~decoded_wr_biten[8:8]) | (decoded_wr_data[8:8] & decoded_wr_biten[8:8]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCER.CC3E.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCER.CC3E.next = next_c;
        field_combo.TIMx_CCER.CC3E.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCER.CC3E.load_next) begin
            field_storage.TIMx_CCER.CC3E.value <= field_combo.TIMx_CCER.CC3E.next;
        end
    end
    assign hwif_out.TIMx_CCER.CC3E.value = field_storage.TIMx_CCER.CC3E.value;
    // Field: CSR_GPT.TIMx_CCER.CC3P
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCER.CC3P.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCER.CC3P.value & ~decoded_wr_biten[9:9]) | (decoded_wr_data[9:9] & decoded_wr_biten[9:9]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCER.CC3P.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCER.CC3P.next = next_c;
        field_combo.TIMx_CCER.CC3P.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCER.CC3P.load_next) begin
            field_storage.TIMx_CCER.CC3P.value <= field_combo.TIMx_CCER.CC3P.next;
        end
    end
    assign hwif_out.TIMx_CCER.CC3P.value = field_storage.TIMx_CCER.CC3P.value;
    assign hwif_out.TIMx_CCER.reserved_10.value = 1'h0;
    // Field: CSR_GPT.TIMx_CCER.CC3NP
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCER.CC3NP.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCER.CC3NP.value & ~decoded_wr_biten[11:11]) | (decoded_wr_data[11:11] & decoded_wr_biten[11:11]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCER.CC3NP.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCER.CC3NP.next = next_c;
        field_combo.TIMx_CCER.CC3NP.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCER.CC3NP.load_next) begin
            field_storage.TIMx_CCER.CC3NP.value <= field_combo.TIMx_CCER.CC3NP.next;
        end
    end
    assign hwif_out.TIMx_CCER.CC3NP.value = field_storage.TIMx_CCER.CC3NP.value;
    // Field: CSR_GPT.TIMx_CCER.CC4E
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCER.CC4E.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCER.CC4E.value & ~decoded_wr_biten[12:12]) | (decoded_wr_data[12:12] & decoded_wr_biten[12:12]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCER.CC4E.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCER.CC4E.next = next_c;
        field_combo.TIMx_CCER.CC4E.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCER.CC4E.load_next) begin
            field_storage.TIMx_CCER.CC4E.value <= field_combo.TIMx_CCER.CC4E.next;
        end
    end
    assign hwif_out.TIMx_CCER.CC4E.value = field_storage.TIMx_CCER.CC4E.value;
    // Field: CSR_GPT.TIMx_CCER.CC4P
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCER.CC4P.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCER.CC4P.value & ~decoded_wr_biten[13:13]) | (decoded_wr_data[13:13] & decoded_wr_biten[13:13]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCER.CC4P.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCER.CC4P.next = next_c;
        field_combo.TIMx_CCER.CC4P.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCER.CC4P.load_next) begin
            field_storage.TIMx_CCER.CC4P.value <= field_combo.TIMx_CCER.CC4P.next;
        end
    end
    assign hwif_out.TIMx_CCER.CC4P.value = field_storage.TIMx_CCER.CC4P.value;
    assign hwif_out.TIMx_CCER.reserved_14.value = 1'h0;
    // Field: CSR_GPT.TIMx_CCER.CC4NP
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIMx_CCER.CC4NP.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIMx_CCER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIMx_CCER.CC4NP.value & ~decoded_wr_biten[15:15]) | (decoded_wr_data[15:15] & decoded_wr_biten[15:15]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIMx_CCER.CC4NP.next;
            load_next_c = '1;
        end
        field_combo.TIMx_CCER.CC4NP.next = next_c;
        field_combo.TIMx_CCER.CC4NP.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIMx_CCER.CC4NP.load_next) begin
            field_storage.TIMx_CCER.CC4NP.value <= field_combo.TIMx_CCER.CC4NP.next;
        end
    end
    assign hwif_out.TIMx_CCER.CC4NP.value = field_storage.TIMx_CCER.CC4NP.value;
    // Field: CSR_GPT.TIM_CNT.CNT
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_CNT.CNT.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_CNT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_CNT.CNT.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIM_CNT.CNT.next;
            load_next_c = '1;
        end
        field_combo.TIM_CNT.CNT.next = next_c;
        field_combo.TIM_CNT.CNT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_CNT.CNT.load_next) begin
            field_storage.TIM_CNT.CNT.value <= field_combo.TIM_CNT.CNT.next;
        end
    end
    assign hwif_out.TIM_CNT.CNT.value = field_storage.TIM_CNT.CNT.value;
    // Field: CSR_GPT.TIM_PSC.PSC
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_PSC.PSC.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_PSC && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_PSC.PSC.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIM_PSC.PSC.next;
            load_next_c = '1;
        end
        field_combo.TIM_PSC.PSC.next = next_c;
        field_combo.TIM_PSC.PSC.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_PSC.PSC.load_next) begin
            field_storage.TIM_PSC.PSC.value <= field_combo.TIM_PSC.PSC.next;
        end
    end
    assign hwif_out.TIM_PSC.PSC.value = field_storage.TIM_PSC.PSC.value;
    // Field: CSR_GPT.TIM_ARR.ARR
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_ARR.ARR.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_ARR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_ARR.ARR.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIM_ARR.ARR.next;
            load_next_c = '1;
        end
        field_combo.TIM_ARR.ARR.next = next_c;
        field_combo.TIM_ARR.ARR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_ARR.ARR.load_next) begin
            field_storage.TIM_ARR.ARR.value <= field_combo.TIM_ARR.ARR.next;
        end
    end
    assign hwif_out.TIM_ARR.ARR.value = field_storage.TIM_ARR.ARR.value;
    // Field: CSR_GPT.TIM_CCR1.CCR1
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TIM_CCR1.CCR1.value;
        load_next_c = '0;
        if(decoded_reg_strb.TIM_CCR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TIM_CCR1.CCR1.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.TIM_CCR1.CCR1.next;
            load_next_c = '1;
        end
        field_combo.TIM_CCR1.CCR1.next = next_c;
        field_combo.TIM_CCR1.CCR1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.TIM_CCR1.CCR1.load_next) begin
            field_storage.TIM_CCR1.CCR1.value <= field_combo.TIM_CCR1.CCR1.next;
        end
    end
    assign hwif_out.TIM_CCR1.CCR1.value = field_storage.TIM_CCR1.CCR1.value;

    //--------------------------------------------------------------------------
    // Write response
    //--------------------------------------------------------------------------
    assign cpuif_wr_ack = decoded_req & decoded_req_is_wr;
    // Writes are always granted with no error response
    assign cpuif_wr_err = '0;

    //--------------------------------------------------------------------------
    // Readback
    //--------------------------------------------------------------------------

    logic readback_err;
    logic readback_done;
    logic [31:0] readback_data;

    // Assign readback values to a flattened array
    logic [31:0] readback_array[12];
    assign readback_array[0][0:0] = '0;
    assign readback_array[0][1:1] = (decoded_reg_strb.TIM_CR1 && !decoded_req_is_wr) ? field_storage.TIM_CR1.CEN.value : '0;
    assign readback_array[0][2:2] = (decoded_reg_strb.TIM_CR1 && !decoded_req_is_wr) ? field_storage.TIM_CR1.URS.value : '0;
    assign readback_array[0][3:3] = (decoded_reg_strb.TIM_CR1 && !decoded_req_is_wr) ? field_storage.TIM_CR1.OPM.value : '0;
    assign readback_array[0][4:4] = (decoded_reg_strb.TIM_CR1 && !decoded_req_is_wr) ? field_storage.TIM_CR1.DIR.value : '0;
    assign readback_array[0][6:5] = (decoded_reg_strb.TIM_CR1 && !decoded_req_is_wr) ? field_storage.TIM_CR1.CMS.value : '0;
    assign readback_array[0][7:7] = (decoded_reg_strb.TIM_CR1 && !decoded_req_is_wr) ? field_storage.TIM_CR1.APRE.value : '0;
    assign readback_array[0][9:8] = (decoded_reg_strb.TIM_CR1 && !decoded_req_is_wr) ? field_storage.TIM_CR1.CKD.value : '0;
    assign readback_array[0][31:10] = '0;
    assign readback_array[1][2:0] = (decoded_reg_strb.TIM_CR2 && !decoded_req_is_wr) ? 3'h0 : '0;
    assign readback_array[1][3:3] = (decoded_reg_strb.TIM_CR2 && !decoded_req_is_wr) ? field_storage.TIM_CR2.CCDS.value : '0;
    assign readback_array[1][6:4] = (decoded_reg_strb.TIM_CR2 && !decoded_req_is_wr) ? field_storage.TIM_CR2.MMS.value : '0;
    assign readback_array[1][7:7] = (decoded_reg_strb.TIM_CR2 && !decoded_req_is_wr) ? field_storage.TIM_CR2.T11S.value : '0;
    assign readback_array[1][15:8] = (decoded_reg_strb.TIM_CR2 && !decoded_req_is_wr) ? 8'h0 : '0;
    assign readback_array[1][31:16] = '0;
    assign readback_array[2][2:0] = (decoded_reg_strb.TIM_SMCR && !decoded_req_is_wr) ? field_storage.TIM_SMCR.SMS.value : '0;
    assign readback_array[2][3:3] = (decoded_reg_strb.TIM_SMCR && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[2][6:4] = (decoded_reg_strb.TIM_SMCR && !decoded_req_is_wr) ? field_storage.TIM_SMCR.TS.value : '0;
    assign readback_array[2][7:7] = (decoded_reg_strb.TIM_SMCR && !decoded_req_is_wr) ? field_storage.TIM_SMCR.MSM.value : '0;
    assign readback_array[2][11:8] = (decoded_reg_strb.TIM_SMCR && !decoded_req_is_wr) ? field_storage.TIM_SMCR.ETF.value : '0;
    assign readback_array[2][13:12] = (decoded_reg_strb.TIM_SMCR && !decoded_req_is_wr) ? field_storage.TIM_SMCR.ETPS.value : '0;
    assign readback_array[2][14:14] = (decoded_reg_strb.TIM_SMCR && !decoded_req_is_wr) ? field_storage.TIM_SMCR.ECE.value : '0;
    assign readback_array[2][15:15] = (decoded_reg_strb.TIM_SMCR && !decoded_req_is_wr) ? field_storage.TIM_SMCR.ETP.value : '0;
    assign readback_array[2][31:16] = '0;
    assign readback_array[3][0:0] = (decoded_reg_strb.TIMx_DIER && !decoded_req_is_wr) ? field_storage.TIMx_DIER.UIE.value : '0;
    assign readback_array[3][1:1] = (decoded_reg_strb.TIMx_DIER && !decoded_req_is_wr) ? field_storage.TIMx_DIER.CC1IE.value : '0;
    assign readback_array[3][2:2] = (decoded_reg_strb.TIMx_DIER && !decoded_req_is_wr) ? field_storage.TIMx_DIER.CC2IE.value : '0;
    assign readback_array[3][3:3] = (decoded_reg_strb.TIMx_DIER && !decoded_req_is_wr) ? field_storage.TIMx_DIER.CC3IE.value : '0;
    assign readback_array[3][4:4] = (decoded_reg_strb.TIMx_DIER && !decoded_req_is_wr) ? field_storage.TIMx_DIER.CC4IE.value : '0;
    assign readback_array[3][5:5] = (decoded_reg_strb.TIMx_DIER && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[3][6:6] = (decoded_reg_strb.TIMx_DIER && !decoded_req_is_wr) ? field_storage.TIMx_DIER.TIE.value : '0;
    assign readback_array[3][7:7] = (decoded_reg_strb.TIMx_DIER && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[3][8:8] = (decoded_reg_strb.TIMx_DIER && !decoded_req_is_wr) ? field_storage.TIMx_DIER.UDE.value : '0;
    assign readback_array[3][9:9] = (decoded_reg_strb.TIMx_DIER && !decoded_req_is_wr) ? field_storage.TIMx_DIER.CC1DE.value : '0;
    assign readback_array[3][10:10] = (decoded_reg_strb.TIMx_DIER && !decoded_req_is_wr) ? field_storage.TIMx_DIER.CC2DE.value : '0;
    assign readback_array[3][11:11] = (decoded_reg_strb.TIMx_DIER && !decoded_req_is_wr) ? field_storage.TIMx_DIER.CC3DE.value : '0;
    assign readback_array[3][12:12] = (decoded_reg_strb.TIMx_DIER && !decoded_req_is_wr) ? field_storage.TIMx_DIER.CC4DE.value : '0;
    assign readback_array[3][13:13] = (decoded_reg_strb.TIMx_DIER && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[3][14:14] = (decoded_reg_strb.TIMx_DIER && !decoded_req_is_wr) ? field_storage.TIMx_DIER.TDE.value : '0;
    assign readback_array[3][15:15] = (decoded_reg_strb.TIMx_DIER && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[3][31:16] = '0;
    assign readback_array[4][0:0] = (decoded_reg_strb.TIMx_SR && !decoded_req_is_wr) ? field_storage.TIMx_SR.UIF.value : '0;
    assign readback_array[4][1:1] = (decoded_reg_strb.TIMx_SR && !decoded_req_is_wr) ? field_storage.TIMx_SR.CC1IF.value : '0;
    assign readback_array[4][2:2] = (decoded_reg_strb.TIMx_SR && !decoded_req_is_wr) ? field_storage.TIMx_SR.CC2IF.value : '0;
    assign readback_array[4][3:3] = (decoded_reg_strb.TIMx_SR && !decoded_req_is_wr) ? field_storage.TIMx_SR.CC3IF.value : '0;
    assign readback_array[4][4:4] = (decoded_reg_strb.TIMx_SR && !decoded_req_is_wr) ? field_storage.TIMx_SR.CC4IF.value : '0;
    assign readback_array[4][5:5] = (decoded_reg_strb.TIMx_SR && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[4][6:6] = (decoded_reg_strb.TIMx_SR && !decoded_req_is_wr) ? field_storage.TIMx_SR.TIF.value : '0;
    assign readback_array[4][8:7] = (decoded_reg_strb.TIMx_SR && !decoded_req_is_wr) ? 2'h0 : '0;
    assign readback_array[4][9:9] = (decoded_reg_strb.TIMx_SR && !decoded_req_is_wr) ? field_storage.TIMx_SR.CC1OF.value : '0;
    assign readback_array[4][10:10] = (decoded_reg_strb.TIMx_SR && !decoded_req_is_wr) ? field_storage.TIMx_SR.CC2OF.value : '0;
    assign readback_array[4][11:11] = (decoded_reg_strb.TIMx_SR && !decoded_req_is_wr) ? field_storage.TIMx_SR.CC3OF.value : '0;
    assign readback_array[4][12:12] = (decoded_reg_strb.TIMx_SR && !decoded_req_is_wr) ? field_storage.TIMx_SR.CC4OF.value : '0;
    assign readback_array[4][15:13] = (decoded_reg_strb.TIMx_SR && !decoded_req_is_wr) ? 3'h0 : '0;
    assign readback_array[4][31:16] = '0;
    assign readback_array[5][0:0] = (decoded_reg_strb.TIMx_EGR && !decoded_req_is_wr) ? field_storage.TIMx_EGR.UG.value : '0;
    assign readback_array[5][1:1] = (decoded_reg_strb.TIMx_EGR && !decoded_req_is_wr) ? field_storage.TIMx_EGR.CC1G.value : '0;
    assign readback_array[5][2:2] = (decoded_reg_strb.TIMx_EGR && !decoded_req_is_wr) ? field_storage.TIMx_EGR.CC2G.value : '0;
    assign readback_array[5][3:3] = (decoded_reg_strb.TIMx_EGR && !decoded_req_is_wr) ? field_storage.TIMx_EGR.CC3G.value : '0;
    assign readback_array[5][4:4] = (decoded_reg_strb.TIMx_EGR && !decoded_req_is_wr) ? field_storage.TIMx_EGR.CC4G.value : '0;
    assign readback_array[5][5:5] = (decoded_reg_strb.TIMx_EGR && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[5][6:6] = (decoded_reg_strb.TIMx_EGR && !decoded_req_is_wr) ? field_storage.TIMx_EGR.TG.value : '0;
    assign readback_array[5][15:7] = (decoded_reg_strb.TIMx_EGR && !decoded_req_is_wr) ? 9'h0 : '0;
    assign readback_array[5][31:16] = '0;
    assign readback_array[6][1:0] = (decoded_reg_strb.TIMx_CCMR1 && !decoded_req_is_wr) ? field_storage.TIMx_CCMR1.CC1S.value : '0;
    assign readback_array[6][2:2] = (decoded_reg_strb.TIMx_CCMR1 && !decoded_req_is_wr) ? field_storage.TIMx_CCMR1.OC1FE_IC1PSC0.value : '0;
    assign readback_array[6][3:3] = (decoded_reg_strb.TIMx_CCMR1 && !decoded_req_is_wr) ? field_storage.TIMx_CCMR1.OC1PE_IC1PSC1.value : '0;
    assign readback_array[6][6:4] = (decoded_reg_strb.TIMx_CCMR1 && !decoded_req_is_wr) ? field_storage.TIMx_CCMR1.OC1M_IC1F.value : '0;
    assign readback_array[6][7:7] = (decoded_reg_strb.TIMx_CCMR1 && !decoded_req_is_wr) ? field_storage.TIMx_CCMR1.OC1CE_IC1F3.value : '0;
    assign readback_array[6][9:8] = (decoded_reg_strb.TIMx_CCMR1 && !decoded_req_is_wr) ? field_storage.TIMx_CCMR1.CC2S.value : '0;
    assign readback_array[6][10:10] = (decoded_reg_strb.TIMx_CCMR1 && !decoded_req_is_wr) ? field_storage.TIMx_CCMR1.OC2FE_IC2PSC0.value : '0;
    assign readback_array[6][11:11] = (decoded_reg_strb.TIMx_CCMR1 && !decoded_req_is_wr) ? field_storage.TIMx_CCMR1.OC2PE_IC2PSC1.value : '0;
    assign readback_array[6][14:12] = (decoded_reg_strb.TIMx_CCMR1 && !decoded_req_is_wr) ? field_storage.TIMx_CCMR1.OC2M_IC2F.value : '0;
    assign readback_array[6][15:15] = (decoded_reg_strb.TIMx_CCMR1 && !decoded_req_is_wr) ? field_storage.TIMx_CCMR1.OC2CE_IC2F3.value : '0;
    assign readback_array[6][31:16] = '0;
    assign readback_array[7][0:0] = (decoded_reg_strb.TIMx_CCER && !decoded_req_is_wr) ? field_storage.TIMx_CCER.CC1E.value : '0;
    assign readback_array[7][1:1] = (decoded_reg_strb.TIMx_CCER && !decoded_req_is_wr) ? field_storage.TIMx_CCER.CC1P.value : '0;
    assign readback_array[7][2:2] = (decoded_reg_strb.TIMx_CCER && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[7][3:3] = (decoded_reg_strb.TIMx_CCER && !decoded_req_is_wr) ? field_storage.TIMx_CCER.CC1NP.value : '0;
    assign readback_array[7][4:4] = (decoded_reg_strb.TIMx_CCER && !decoded_req_is_wr) ? field_storage.TIMx_CCER.CC2E.value : '0;
    assign readback_array[7][5:5] = (decoded_reg_strb.TIMx_CCER && !decoded_req_is_wr) ? field_storage.TIMx_CCER.CC2P.value : '0;
    assign readback_array[7][6:6] = (decoded_reg_strb.TIMx_CCER && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[7][7:7] = (decoded_reg_strb.TIMx_CCER && !decoded_req_is_wr) ? field_storage.TIMx_CCER.CC2NP.value : '0;
    assign readback_array[7][8:8] = (decoded_reg_strb.TIMx_CCER && !decoded_req_is_wr) ? field_storage.TIMx_CCER.CC3E.value : '0;
    assign readback_array[7][9:9] = (decoded_reg_strb.TIMx_CCER && !decoded_req_is_wr) ? field_storage.TIMx_CCER.CC3P.value : '0;
    assign readback_array[7][10:10] = (decoded_reg_strb.TIMx_CCER && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[7][11:11] = (decoded_reg_strb.TIMx_CCER && !decoded_req_is_wr) ? field_storage.TIMx_CCER.CC3NP.value : '0;
    assign readback_array[7][12:12] = (decoded_reg_strb.TIMx_CCER && !decoded_req_is_wr) ? field_storage.TIMx_CCER.CC4E.value : '0;
    assign readback_array[7][13:13] = (decoded_reg_strb.TIMx_CCER && !decoded_req_is_wr) ? field_storage.TIMx_CCER.CC4P.value : '0;
    assign readback_array[7][14:14] = (decoded_reg_strb.TIMx_CCER && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[7][15:15] = (decoded_reg_strb.TIMx_CCER && !decoded_req_is_wr) ? field_storage.TIMx_CCER.CC4NP.value : '0;
    assign readback_array[7][31:16] = '0;
    assign readback_array[8][31:0] = (decoded_reg_strb.TIM_CNT && !decoded_req_is_wr) ? field_storage.TIM_CNT.CNT.value : '0;
    assign readback_array[9][31:0] = (decoded_reg_strb.TIM_PSC && !decoded_req_is_wr) ? field_storage.TIM_PSC.PSC.value : '0;
    assign readback_array[10][31:0] = (decoded_reg_strb.TIM_ARR && !decoded_req_is_wr) ? field_storage.TIM_ARR.ARR.value : '0;
    assign readback_array[11][31:0] = (decoded_reg_strb.TIM_CCR1 && !decoded_req_is_wr) ? field_storage.TIM_CCR1.CCR1.value : '0;

    // Reduce the array
    always_comb begin
        automatic logic [31:0] readback_data_var;
        readback_done = decoded_req & ~decoded_req_is_wr;
        readback_err = '0;
        readback_data_var = '0;
        for(int i=0; i<12; i++) readback_data_var |= readback_array[i];
        readback_data = readback_data_var;
    end

    assign cpuif_rd_ack = readback_done;
    assign cpuif_rd_data = readback_data;
    assign cpuif_rd_err = readback_err;
endmodule
